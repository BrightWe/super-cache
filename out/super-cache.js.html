<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: super-cache.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: super-cache.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * SuperCache
 * 功能点
 * 1. 满足一般的缓存需求，读取（get）和保存（set）
 * 2. 允许通过 adapter 来代理某一个 key 的参数获取逻辑，如果定义了 adapter，则会拿到 adapter 的值，然后更新缓存。
 * 3. 默认情况下，get 会优先读取缓存的数据，如果没有，则会调用 adapter 获取数据。
 * 4. 如若要主动去根据 adapter 更新某个 key 的缓存数据，调用 updateByAdapter(key)
 * 5. 改库持久化数据的方式，有外部来定义，通过 storage.set 和 storage.get
 */

import { log } from "./inner-log";

/** Class SuperCache. */
class SuperCache {

    /**
     * @callback storageSet
     * @param {string} key 需要获取数据的 key
     * @param {*} data 需要存储的数据
     */

    /**
     * @callback storageGet
     * @param {string} key 需要获取数据的 key
     * @returns {Promise | *} 如果返回非 Promise，内部会转化为 Promise
     */

    /**
     * Create an instance of SuperCache
     * @param {object} options 配置信息
     * @param {object} options.storage 外部需要定义的数据存储器
     * @param {storageSet} options.storage.set 数据保存
     * @param {storageGet} options.storage.get 数据获取
     * @param {boolean} [options.ignoreCache=false] 是否忽略缓存
     * @param {boolean} [options.updateCache=true] 是否更新缓存
     * @param {object} [options.log] 允许改变内部的 log 库
     *
     */
    constructor({
        ignoreCache = false,
        updateCache = true,
        storage,
        log,
    } = {}) {
        this.adapters = {};

        if (!storage) throw new Error('storage must exit');
        if (typeof storage.get !== 'function') throw new Error('storage.get must typeof function');
        if (typeof storage.set !== 'function') throw new Error('storage.set must typeof function');
        this.getData = key => storage.get.call(this, `super-cache:${key}`);
        this.setData = (key, value) => storage.set.call(this, `super-cache:${key}`, value);
        this.log = log;

        this.defaultOpt = { ignoreCache, updateCache };
    }

    /**
     * Get value
     * @param {string} key 需要获取数据的 key
     * @param {object} options 配置信息
     * @param {boolean} [options.ignoreCache=false] 是否忽略缓存
     * @param {boolean} [options.updateCache=true] 是否更新缓存
     * @param {optionsBeforeGet} [options.beforeGet] 在调用 adapter 获取数据之前的钩子方法
     */
    get(key, options) {
        const domain = {};
        return Promise
            .resolve()
            .then(() => {
                const adapter = this.adapters[key];
                domain.adapter = adapter;
                domain.opt = Object.assign({}, this.defaultOpt, adapter, options);
            })
            .then(() => this.getData(key))
            .then((cacheValue) => { domain.cacheValue = cacheValue; })
            .then(() => {
                // 如果 beforeGet 存在，则执行，然后覆盖 opt
                if (typeof domain.opt.beforeGet === 'function') {
                    return Promise
                        .resolve()
                        .then(() => domain.opt.beforeGet(domain.cacheValue))
                        .then((opt) => { domain.opt = Object.assign({}, domain.opt, opt); });
                }
                return Promise.resolve();
            })

            .then(() => {
                if (typeof domain.cacheValue === 'undefined' || domain.opt.ignoreCache === true) {
                    return this
                        .getAdapterValue(key)
                        .then((value) => {
                            if (domain.opt.updateCache === true) this.setData(key, value);
                            return value;
                        });
                }

                if (domain.opt.updateAfterGet) this.updateByAdapter(key);

                return domain.cacheValue;
            });
    }

    /**
     * Set value
     * @param {string} key 需要获取数据的 key
     * @param {*} value key 对应的数据
     */
    set(key, value) {
        this.setData(key, value);
    }

    /**
     * Get value by adapter
     * @param {string} key 需要获取数据的 key
     * @returns {Promise}  返回一个 Promise 对象，该对象返回需要获取的数据
     */
    getAdapterValue(key) {
        const adapter = this.adapters[key];
        if (!adapter) throw new Error(`adapter ${key} was undefined`);
        return Promise.resolve().then(() => adapter.data());
    }

    /**
     * Update value by adapter
     * @param {string} key 需要获取数据的 key
     * @returns {Promise} 返回一个 Promise 对象，该对象返回需要获取的数据
     */
    updateByAdapter(key) {
        return this
            .getAdapterValue(key)
            .then((value) => {
                this.setData(key, value);
                return value;
            });
    }


    /**
     * beforeGet callback
     * @callback optionsBeforeGet
     * @param {*} cache 存储在 storage 的缓存数据，如果没有则为 undefined
     * @return {object} runtimeOpt 运行时的配置信息，会暂时覆盖实例的配置
     */

    /**
     * data callback
     * @callback optionsData
     * @returns {Promise} 需要返回一个 Promise 对象，该对象返回需要存储的数据
     */

    /**
     * Add adapter
     * @param {string} key 
     * @param {object|function} options 如果是 object，参数看下面，如果是function，则会变成 options.data = options
     * @param {boolean} [options.ignoreCache=false] 是否忽略缓存
     * @param {boolean} [options.updateCache=true] 是否更新缓存
     * @param {optionsBeforeGet} [options.beforeGet] 在调用 adapter 获取数据之前的钩子方法
     * @param {optionsData} options.data 在调用 adapter，通过该函数来获取数据
     */
    addAdapter(key, options) {
        let adapter = options;
        if (this.adapters[key]) throw new Error(`adapter ${key} not allowed to be repeat definition`);
        if (typeof options === 'function') adapter = { data: options };
        else if (typeof options.data !== 'function') throw new Error('data() must typeof function');
        this.log.info('super-cache:addAdatper', `adapter ${key} was attatched`);
        this.adapters[key] = adapter;
    }
}

export default SuperCache;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="SuperCache.html">SuperCache</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Sep 23 2018 12:26:05 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
